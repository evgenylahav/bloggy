(window.webpackJsonp=window.webpackJsonp||[]).push([[0],{237:function(e,t,n){},245:function(e,t,n){},246:function(e,t,n){"use strict";n.r(t);var a=n(0),r=n.n(a),o=n(16),l=n.n(o),i=(n(41),n(17)),s=n(18),c=n(20),u=n(19),d=n(21),m=n(9),h=n(10),p=function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"Hello, welcome to my blog!"),r.a.createElement("p",null,"Welcome to my blog! In this blog I will publish from time to time topics of interests in the SW engineering world. Specifically: web development, python, clean code and more."),r.a.createElement("p",null,"This web page was developed as part of my full-stack web applications development training and is based on the LinkedIn Learning course: React: Creating and Hosting a Full-stack Site by Shaun Wassel, which is extremely recommended."))},f=function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"About me"),r.a.createElement("p",null,"I am Evgeny Lahav - a software developer. I have been programming for a long time but only in the resent years I've discovered the beauty and the complexity of it. I also developed a passion for SW engineering and architecture and spend a lot of my personal time to enhance my capabilities and knowledge."),r.a.createElement("p",null,"The topics that interest me are Python development, JavaScript both as front-end and back-end, software design and architecture and clean coding. Most of the blogs will be around these topics."),r.a.createElement("p",null,"The technologies that were used to develop this blog are:",r.a.createElement("ul",null,r.a.createElement("li",null,"Front-end - ReactJS"),r.a.createElement("li",null,"Back-end - NodeJS"),r.a.createElement("li",null,"Web server - Express"),r.a.createElement("li",null,"Database - MongoDB")),"The web site is deployed and hosted in AWS."),r.a.createElement("p",null,"Being a full-stack application, this blog allows you to upvote the blogs and to comment about them. I will try my best to maintain and enhance this blog as much as possible, within my time boundaries."),r.a.createElement("p",null,"Enjoy!!"))},g=function(e){var t=e.articles;return r.a.createElement(r.a.Fragment,null,t.map(function(e,t){return r.a.createElement(m.b,{className:"article-list-item",key:t,to:"/article/".concat(e.name)},r.a.createElement("div",null,r.a.createElement("h3",null,e.title),r.a.createElement("p",null,e.intro)),r.a.createElement("div",null,r.a.createElement("img",{alt:"article",src:e.imgSrc,width:"200",height:"100",style:{marginTop:"70px"}})))}))},_=[{name:"full-stack-development",title:"7 Minutes about Full Stack Development",componentName:"FullStackDevBlog",intro:"Full stack developer is a term we hear all over the place. It became one of the most desirable positions \n        for developers in the industry. In this blog I will describe my personal view of this idea of full-stack development,\n        as well as some general concepts and technologies behind it.",imgSrc:"https://hackernoon.com/hn-images/1*9npNPVH7iNJ64Koq7EcW5A.jpeg"},{name:"python-classes",title:"Python: Constructing Classes",componentName:"PythonClassesBlog",intro:"This topic is a corner stone for SW development in general and in O.O languages as Python in particular. There are a lot of general good practices for constructing classes, and some that are specific to Python. This blog will cover some of these concepts. ",imgSrc:"https://s3.ap-south-1.amazonaws.com/atg-storage-s3/assets/Frontend/images/article_image/article-03440000002019214749270.jpg"},{name:"python-decorators",title:"Python: Decorators",componentName:"PythonDecoratorsBlog",intro:"A decorator is a function that takes another function as an argument and returns a different function as an output. \n        Decorators are a great way to wrap existing functions and add some functionality to them. This blog will cover some of these concepts.",imgSrc:"https://tasdikrahman.me/content/images/2016/7/decorators.png"},{name:"python-dependencies-management",title:"Python: Dependencies Management",componentName:"PythonDependenciesManagementBlog",intro:"It is very important to understand the dependencies management and environments management in Python.\n        There are general purpose installers as anaconda and miniconda (https://conda.io/miniconda.html). However when developing production products, it is generally a good idea\n        to bring the working environment as close as possible to production. That is done by working with virtual environments. This blog will discuss this issue\n        and suggest a few best known methods to follow.",imgSrc:"https://opensource.com/sites/default/files/styles/image-full-size/public/lead-images/python_snake_file_box.jpg?itok=UuDVFLX-"},{name:"python-dunders",title:"Python: Dunders",componentName:"PythonDundersBlog",intro:"Dunder stands for double-underscore. Dunders are also known as special methods or magical methods.                         \n        In Python, special methods are a set of predefined methods you can use to enrich your classes. This blog will\n        discuss some good practices and common usages of dunders in Python.",imgSrc:"https://www.python-course.eu/images/marvin_the_magician.png"},{name:"python-first-order-functions",title:"Python: First Order Functions and Closures",componentName:"PythonFirstOrderFunctionsBlog",intro:"First order functions and closures are an important concept in Python. \n        As we know, everything in Python is an object with regular and special methods. \n        First order functions and closures are also an important concepts for explaining \n        and using decorators. This blog will review and explain these concepts.",imgSrc:"https://dbader.org/static/figures/python-first-class-functions.png"},{name:"python-functions",title:"Python Blog: Enhance your functions",componentName:"PythonFunctionsBlog",intro:"Functions are the most basic and important components in our programs. There are many \n        interesting features and capabilities provided in Python, to make our functions better and \n        less prone to errors. In this blog we will review some of these features.",imgSrc:"https://i1.wp.com/technologyexplain.com/wp-content/uploads/2019/06/Python-Functions.png?fit=1275%2C751&ssl=1"},{name:"python-generators",title:"Python Blog: Generators and Iterators",componentName:"PythonGeneratorsBlog",intro:"This blog will discuss two important Pythonic concepts of generators and iterators.\n        Simply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time).\n        This blog will discuss the differences between these concepts and provide some useful examples.",imgSrc:"https://d2h0cx97tjks2p.cloudfront.net/blogs/wp-content/uploads/sites/2/2018/01/Python-Generators-vs-Iterators-01.jpg"},{name:"python-named-tuple",title:"Python Blog: Collections Module - namedtuple()",componentName:"PythonNamedTupleBlog",intro:"Collections module provides special enhancements for the regular containers in Python, \n        such as dict, list, tuple and set. This blog will cover the namedtuple() factory function \n        that creates tuples with named fields.",imgSrc:"https://i.ytimg.com/vi/GfxJYp9_nJA/maxresdefault.jpg"}],w=function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,"Articles"),r.a.createElement(g,{articles:_}))},b=n(8),y=n.n(b),E=n(13),v=n(15),k=function(){return r.a.createElement("h1",null,"404: Page Not Found")},x=function(e){var t=e.comments;return r.a.createElement(r.a.Fragment,null,r.a.createElement("h3",null,"Comments:"),t.map(function(e,t){return r.a.createElement("div",{className:"comment",key:t},r.a.createElement("h4",null,e.username),r.a.createElement("p",null,e.text))}))},T=function(e){var t=e.articleName,n=e.upvotes,a=e.setArticleInfo,o=function(){var e=Object(E.a)(y.a.mark(function e(){var n,r;return y.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("/api/articles/".concat(t,"/upvote"),{method:"post"});case 2:return n=e.sent,e.next=5,n.json();case 5:r=e.sent,a(r);case 7:case"end":return e.stop()}},e)}));return function(){return e.apply(this,arguments)}}();return r.a.createElement("div",{id:"upvotes-section"},r.a.createElement("button",{onClick:function(){return o()}},"Add upvote"),r.a.createElement("p",null,"This post has been upvoted ",n," times"))},A=function(e){var t=e.articleName,n=e.setArticleInfo,o=Object(a.useState)(""),l=Object(v.a)(o,2),i=l[0],s=l[1],c=Object(a.useState)(""),u=Object(v.a)(c,2),d=u[0],m=u[1],h=function(){var e=Object(E.a)(y.a.mark(function e(){var a,r;return y.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("/api/articles/".concat(t,"/add-comment"),{method:"post",body:JSON.stringify({username:i,text:d}),headers:{"Content-Type":"application/json"}});case 2:return a=e.sent,e.next=5,a.json();case 5:r=e.sent,n(r),s(""),m("");case 9:case"end":return e.stop()}},e)}));return function(){return e.apply(this,arguments)}}();return r.a.createElement("div",{id:"add-comment-form"},r.a.createElement("h3",null,"Add a Comment"),r.a.createElement("label",null,"Name:",r.a.createElement("input",{type:"text",value:i,onChange:function(e){return s(e.target.value)}})),r.a.createElement("label",null,"Comment:",r.a.createElement("textarea",{rows:"4",cols:"50",value:d,onChange:function(e){return m(e.target.value)}})),r.a.createElement("button",{onClick:function(){return h()}},"Add comment"))},I=function(){return r.a.createElement(r.a.Fragment,null,r.a.createElement("h3",null,"Intro"),r.a.createElement("p",null,"Full stack developer is a term we hear all over the place. It became one of the most desirable positions for developers in the industry. In this blog I will describe my personal view of this idea of full-stack development, as well as some general concepts and technologies behind it."),r.a.createElement("p",null,r.a.createElement("i",null,"Note: This blog will not go into coding details.")),r.a.createElement("h3",null,"What is Full Stack Development?"),r.a.createElement("p",null,"When we refer to full-stack development, the usual context is programming in the web environment, and specifically developing the whole parts of a web application by a single developer or a group of developers without a specific separation between different parts of the application."),r.a.createElement("p",null,"To develop a full stack web application we are required to use several technologies. These technologies are usually quite different one from the other and require different skills and knowledge. A developer that can handle all of these technologies technically and conceptualy is considered as a full-stack developer."),r.a.createElement("p",null,"Imagine that a single builder builds the whole house - the walls, the electricity, the water, the plumbing, the floors, the paint, well, you get the picture. It is not likely, for one person to handle all of it. In full-stack development, however, this is exactly what is expected."),r.a.createElement("p",null,"The image below demonstrated the 3 main parts of a full stack application - front-end AKA the client side, back-end AKA the server side and the database."),r.a.createElement("img",{alt:"full-stack scheme",src:"data:image/png;base64,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",height:"300",width:"300"}),";",r.a.createElement("p",null,"There is also a fourth domain which is becoming more and more popular these days - publishing our application, specifically when using the cloud services, which requires yet some more knowledge and expertise that is quite different from the skills required for the application development."),r.a.createElement("p",null,"So, what do you need to become a full stack developer? Which languages, frameworks, tools and databases? The following sections will try to answer that question."),r.a.createElement("h3",null,"Front-End Technologies"),r.a.createElement("p",null,"The front-end part of the web application is often called ",r.a.createElement("u",null,"the client"),", to represent the one part of the application that is accessible to the user (client) for performing actions and getting information. Front-end development takes care of the user interface (UI), including the appearance, the styling, the user experience (UX), the responsiveness of the UI and of course the content."),r.a.createElement("p",null,"It is not possible to be a serious front-end developer without having a solid knowledge in these three technologies:",r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.w3schools.com/html/",target:"blank"},r.a.createElement("b",null,"HTML"))," which is responsible for the content of the website."),r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.w3schools.com/css/",target:"blank"},r.a.createElement("b",null,"CSS / SCSS"))," which is responsible for the stying and the appearance of the website."),r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.w3schools.com/js/",target:"blank"},r.a.createElement("b",null,"JavaScript "))," which is the engine behind and provides the responsiveness and the flexibility of the website.")),"However, it doesn't end here. To develop a modern website, it is very recommended to have a solid knowledge in at least one of the three most famous JavaScript based frameworks:",r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("a",{href:"https://reactjs.org/",target:"blank"},r.a.createElement("b",null,"ReactJS"))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://angular.io/",target:"blank"},r.a.createElement("b",null,"Angular "))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://vuejs.org/",target:"blank"},r.a.createElement("b",null,"Vue")))),"There are others, but these three are the most popular and recommended."),r.a.createElement("p",null,"Knowing all of the above is good, and it will allow you to start doing some nice things in the front-end world. But there is more. A bigger and more complicated application will require to know some more concepts and technologies.",r.a.createElement("ul",null,r.a.createElement("li",null,"State management like ",r.a.createElement("a",{href:"https://redux.js.org/",target:"blank"},r.a.createElement("b",null,"Redux"))),r.a.createElement("li",null,"Testing frameworks like ",r.a.createElement("a",{href:"https://jestjs.io/",target:"blank"},r.a.createElement("b",null,"jest"))," and ",r.a.createElement("li",null,r.a.createElement("a",{href:"https://github.com/airbnb/enzyme",target:"blank"},r.a.createElement("b",null,"enzyme")))),r.a.createElement("li",null,"Mock server to imitate the server without using an actual one. Read more about mock servers ",r.a.createElement("a",{href:"http://www.mock-server.com/",target:"blank"},"here")))),r.a.createElement("p",null,"While HTML and CSS are rather straight forward and easy to learn and understand, JavaScript is different. It is a rich, advanced and fascinating programming language to learn with a huge community of users and information over the internet. Investing time in learning vanilla JavaScript, therfore, is advised, before moving on to the fancy front-end frameworks and the complementary technologies as stated in this section."),r.a.createElement("h3",null,"Back-End Technologies"),r.a.createElement("p",null,'If front-end development is the "face" of the application, back-end development is its "brains" and "internal organs". It gets orders from the user, generates responses, makes queries to the database, performs calculating algorithms, scrapes web pages and many more. Basically, all the business logic of the application is handled in the back-end. Back-end development is also known as server-side development, as it develops the part of the application that serves clients\' requests.'),r.a.createElement("p",null,"Front-end development requirements are somehow specific, as you can't get around the technologies mentioned in the previous part. Back-end development is much more diverse. Many programming languages have the web server capabilities, so there are a lot of choices. Here are some of the most popular ones:",r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.java.com/en/",target:"blank"},r.a.createElement("b",null,"Java"))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.python.org/",target:"blank"},r.a.createElement("b",null,"Python "))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://rubyonrails.org/",target:"blank"},r.a.createElement("b",null,"Ruby on Rails"))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.php.net/",target:"blank"},r.a.createElement("b",null,"PHP"))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://nodejs.org/en/",target:"blank"},r.a.createElement("b",null,"NodeJS")))),"So, what to choose? Well, it depends on different things."),r.a.createElement("p",null,r.a.createElement("u",null,"Application:")," there are programming languages, that are commonly used for certain things. For example, if the main domain of the application is in the Machine Learning, Deep Learning and Artificial Intelligence fields, then it would make a lot of sense to use Python as your main server language."),r.a.createElement("p",null,r.a.createElement("u",null,"Prior knowledge:")," if the application domain doesn't require specific libraries, the logical choice for the server language would be just a language that the programmers are comfortable with."),r.a.createElement("p",null,r.a.createElement("u",null,"Single technology:")," to make things simpler for the full-stack developers, one of the most popular choices for the server side is NodeJS. It is based on JavaScript, it is open source with a great community of developers behind it, and it requires to master only a single programming language and its frameworks - JavaScript (again??)."),r.a.createElement("p",null,"Server side programming organizes the whole app and connects between its different parts. A typical back-end flow would be to listen to the client's requests, generate some action (like approach the database or trigger some action like a calculation algorithms or web scraping) and send a response back to the client."),r.a.createElement("h3",null,"API"),r.a.createElement("p",null,"One of the most important and typical tasks in web development is determining the interfaces between the back-end and the front-end sides. When a web app is developed by a single developer (i.e. full stack developer), this task becomes easier, however it is still extremely important to define and try not to change along the way, unless it is mandatory."),r.a.createElement("p",null,"The most commonly and widely used API is called ",r.a.createElement("a",{href:"https://en.wikipedia.org/wiki/Representational_state_transfer",target:"blank"},r.a.createElement("b",null,"REST API")),". This API is used to pass data between back-end and front-end. For example, if a user triggers an event (like a button click) it can be used to generate an API request from the front-end to the back-end. The back-end will process the request based on the data that it got, and will issue a response, that will be sent back to the front-end code and usually generate some change in the UI. The requests and the responses are generated in a ",r.a.createElement("a",{href:"https://www.json.org/",target:"blank"},r.a.createElement("b",null,"JSON"))," format which are very easy to handle in JavaScript and are very readable and easy to understand."),r.a.createElement("p",null,"Another common way to pass parameters from front-end to back-end is by using query parameters, also known as URL parameters. These values are passed within the URL format with specific keys and can be easily handled on the server side."),r.a.createElement("p",null,"Proper definition of the API allows the developer to work independantly on the front-end and the back-end side and minimize contact switching. It is especially correct when using a mock server to imitate the real server, what makes the integration between the front-end and the back-end much simpler."),r.a.createElement("h3",null,"Databases"),r.a.createElement("p",null,"Every modern and dynamic website, will eventually require using a database. This part is often overlooked by developers who tend and prefer to focus on programming and programming languages but failing to properly define and handle the database part of the app, could cause it to become unreliable and unusable."),r.a.createElement("p",null,"Examples to the usages of databases are:",r.a.createElement("ul",null,r.a.createElement("li",null,"Keeping the user\u2019s personal data (like bank account) safely"),r.a.createElement("li",null,"Persistency of users' actions in the web app, like commenting, liking, quoting, ..."),r.a.createElement("li",null,"Storing personal images and fetching them on demand"),r.a.createElement("li",null,"Video on demand services of the likes of Netflix, Hulo and others."))),r.a.createElement("p",null,"There are two main types of databases: relational (SQL) and non-relational (NoSQL). There are many good databases in each of the types. The most common for the SQL type are MySQL, Oracle and Postgres and for the NoSQL type are MongoDB, Redis and others."),r.a.createElement("p",null,"SQL based databases are basically a collection of tables with schemas, that represent the attributes and the data types within the table. You can read, write, update and delete the data. These databases are well maintained, documented and are very stable."),r.a.createElement("p",null,"NoSQL based databases have started to gain popularity with the increased complexity of the web applications. The more the data is complexed, the harder it is to have it structured and organized, and thus, the usage of NoSQL databases is more convenient for that matter."),r.a.createElement("p",null,"There are many sources over the internet that can help us to pick the right one, but in general, the selection of the database should be based on the type of data that we expect to have. Will it be well structured, like bank accounts, then using the stable and safe SQL databases would be advised. For IoT apps or large analytics, which would require complexed data structures, it would probably be better to use NoSQL."),r.a.createElement("h3",null,"Summary"),r.a.createElement("p",null,"Full-stack development is fascinating. The amount of challenges is huge. The technology is constantly changing and improving, and you must be on the top of your game all the time. You need to understand and work in different environments, and invest a lot of time in design and planning. The reward of the effort in the end is seeing your app running on the World Wide Web. For those who are interested to try it, here are a couple of links for courses to get started."),r.a.createElement("h3",null,"Links"),r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.linkedin.com/learning/react-creating-and-hosting-a-full-stack-site/react-for-full-stack-solutions",target:"blank"},r.a.createElement("b",null,"LinkedIn Learning Course 1"))),r.a.createElement("li",null,r.a.createElement("a",{href:"https://www.linkedin.com/learning/learning-full-stack-javascript-development-mongodb-node-and-react",target:"blank"},r.a.createElement("b",null,"LinkedIn Learning Course 2")))))},j=n(248),P=n(249),S=n(33),N=n.n(S),C=(n(237),function(e){function t(){return Object(i.a)(this,t),Object(c.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){return a.createElement("div",{"data-test":"code-snippet-div"},a.createElement(N.a,{language:this.props.language},this.props.code))}}]),t}(a.Component)),F=function(){return a.createElement(a.Fragment,null,a.createElement(j.a,null,a.createElement("h2",null,"Intro"),a.createElement("p",null,"This topic is a corner stone for SW development in general and in O.O languages as Python in particular. There are a lot of general good practices for constructing classes, and some that are specific to Python. This blog will cover some of these concepts. Enjoy."),a.createElement("h3",null,"Documentation:"),a.createElement("p",null,"What does the class do. Recommended to use: docstrings"),a.createElement(C,{language:"python",code:'class Circle:\n    """\n    advanced circle toolkit\n    """'}),a.createElement("h3",null,"Initialization:"),a.createElement("p",null,"Use the __init__ method to initialize the instance variables. Note: __init__ is not a constructor (more about it later)"),a.createElement(C,{language:"python",code:'    def __init__(self, radius):\n        """\n        __init__ is not a constructor. its job is to initialize the\n        instance variables\n        """\n        self.radius = radius # instance variable'}),a.createElement("h3",null,"Class and instance variables:"),a.createElement("p",null,"Opposed to other OO languages, instance variables and class variables are not protected, and are open for users' modification. In Python, all doors are opened."),a.createElement(C,{language:"python",code:'class Circle:\n    """\n    an advanced circle toolkit\n    """\n    version = "0.1" # class variable'}),a.createElement("p",null,"Class variables have the same values across all class instances. Defined after class definition. Instance variables have different values for each object instance."),a.createElement("h3",null,"Classes inheritance:"),a.createElement("p",null,"Every class is able to inherit from another class and by that to either use, extend or override its functionality. When not defining a specific functionality in the child class, we're using the functionality of the parent class (as for example the __init__ and perimeter methods in the example below). When using the parent class method and adding some functionality to it, we're extending the functionality (as in the perimeter method). When replacing a parent class method with a method of our own, we're overriding its functionality."),a.createElement("p",null,"Defining a perimeter method in the Circle class:"),a.createElement(C,{language:"python",code:"    def perimeter(self):\n        return 2 * math.pi * self.radius"}),a.createElement("p",null,"Defining a new class and overriding the perimeter method:"),a.createElement(C,{language:"python",code:'class Tire(Circle):\n    """\n    Tires are circles with a corrected perimeter calculation\n    """\n    def perimeter(self):\n        return Circle.perimeter(self) * 1.25'}),a.createElement(P.a,{variant:"info"},"When writing classes, expect them to be inherited and modified"),a.createElement("h3",null,"Alternative constructors:"),a.createElement("p",null,"Sometimes we wish to provide several options to construct a class. One way to find those different constructors is by looking for a from_ method. For example:"),a.createElement(C,{language:"python",code:"dict.fromkeys()"}),a.createElement("p",null,"In our example, we are adding a new method and decorating it with a @classmethod decorator."),a.createElement(C,{language:"python",code:'@classmethod\ndef from_bbd(cls, bbd):\n    """ construct a circle from a bounding box diagonal """\n    radius = bbd / 2.0 / math.sqrt(2.0)\n    return cls(radius)'}),a.createElement("p",null,"Note that when returning, we are using the cls instance and not Circle, because, when our sub-classes will use it, we don't want to explicitly return Circle, but the same class type they were using to construct (like Tire for example)"),a.createElement("h3",null,"Adding functionality:"),a.createElement("p",null,"To attach functions to classes we use the @staticmethod decorator."),a.createElement(C,{language:"python",code:'@staticmethod\ndef angle_to_grade(angle):\n    """ convert angle in degree to a percentage grade """\n    return math.tan(math.radians(angle)) * 100.0'}),a.createElement("p",null,"One of the main reasons for attaching functions in such way is to improve the findability of the function and to make sure that it is used in the right context"),a.createElement("h3",null,"Class local references:"),a.createElement("p",null,"Let's assume that we want to update the functionality of our perimeter method. We can just change it, but then we will break the functionality of all the classes that inherit our class. The solution to this issue is to use dunders. In our case, we could define __perimeter method, and then use it within our class. The class local references will not be available for out of class context structures."),a.createElement(C,{language:"python",code:"# usage - self.__perimeter()\n \n \n def __perimeter(self):\n     return 2 * math.pi * self.radius"}),a.createElement("h3",null,"Properties:"),a.createElement("p",null,"Now we have a new request. We need to remove the radius instance variable and to introduce a new one - diameter. One way to do it is to break all our code and API. A better way would be to use properties. A property decorator actually converts dotted access to method calls (which means it replaces a getter) and the radius.setter decorator creates a setter. This way, each time the radius is called, within our class or from outside, it will initiate these two new methods, and the rest of the class remains unchanged."),a.createElement(C,{language:"python",code:'@property\ndef radius(self):\n    """ radius of circle """\n    return self.diameter / 2.0'}),a.createElement(P.a,{variant:"info"},"The main purpose of properties is to avoid using getters in setters in Python."),a.createElement("h3",null,"Summary:"),a.createElement("p",null,"Here is a summary of all the concepts that are supposed to make our classes better:"),a.createElement("ul",null,a.createElement("li",null,"Instance variables for information unique to an instance"),a.createElement("li",null,"Class variables for data shared among all instances"),a.createElement("li",null,"Regular methods need 'self' to operate on instance data"),a.createElement("li",null,"Class methods implement alternative constructors. They need 'cls' so they can create subclass instances as well"),a.createElement("li",null,"Static methods attach functions to classes. They don't need 'self'. Static methods improve discoverability and require context to be specified"),a.createElement("li",null,"Dunder methods are used for a class local references, that is used only within the class"),a.createElement("li",null,"A property() lets getter and setter methods be invoked automatically by attribute access. This allows Python classes to freely expose their instance variables."))))},L=function(){return a.createElement(j.a,null,a.createElement("h2",null,"Intro"),a.createElement("h3",null,"Definition:"),a.createElement("p",null,"A decorator is a function that takes another function as an argument and returns a different function as an output. Decorators use some of the concepts that were described in the first class functions and closures blog. Decorators are a great way to wrap existing functions and add some functionality to them. For example, when we want to keep the existing code base and tests, and add a new functionality, we can use a decorator that will alter the function behavior, without changing its code."),a.createElement("h3",null,"A Simple Example:"),a.createElement("p",null,"A very simple example to a decorator is shown here:"),a.createElement(C,{language:"python",code:'def another_function():\n    print("I\'m another function")\n\n\ndef turn_into_another_function(func):\n    return another_function\n\n\ndef a_function():\n    print("I\'m a function")\n\n\na_function = turn_into_another_function(a_function)\na_function()\n\n>>> I\'m another function'}),a.createElement("p",null,"We can see that the function a_function is assigned with yet another function which is called another_function, and then when a_function is executed, it actually executes another_function."),a.createElement("p",null,"Python has a syntactic sugaring that allows us using decorators in a much prettier way:"),a.createElement(C,{language:"python",code:'def another_function():\n    print("I\'m another function")\n \ndef turn_into_another_function(func):\n    return another_function\n \n@turn_into_another_function\ndef a_function():\n    print("I\'m a function")\n \na_function()\n \n>>> I\'m another function'}),a.createElement("h3",null,"Using inner() function:"),a.createElement("p",null,'The simple example is not something that we will be using in real life code. To be able using decorators, we will define the decorator function as a closure. Let\'s check the following example. Assuming that we have a function that knows how to get a string of a snake form ("hello_world") and to transfer it to a capital camel case form ("HelloWorld"). This is how this function would look like:'),a.createElement(C,{language:"python",code:'def camelcase(s: str) -> str:\n    """ turns string_like to StringLike """\n    return \'\'.join([word.capitalize() for word in s.split(\'_\')])\n \n \nif __name__ == \'__main__\':\n    print(camelcase("hello_world"))\n \n \n>>> camelcase("hello_world")\nHelloWorld'}),a.createElement("p",null,"Now, we want to expand our capabilities so that the input to the camelcase function will be a list of strings. One option is to change the function camelcase(). A better way is to use a decorator as following:"),a.createElement(C,{language:"python",code:'def mapper(func):\n    def inner(list_of_strings):\n        return [func(value) for value in list_of_strings]\n    return inner\n \n@mapper\ndef camelcase(s: str) -> str:\n    """ turns string_like to StringLike """\n    return \'\'.join([word.capitalize() for word in s.split(\'_\')])\n \nnames = ["lebron_james", "michael_jordan", "kobe_bryant"]\nprint(camelcase(names))\n\n \n>>> [\'LebronJames\', \'MichaelJordan\', \'KobeBryant\']'}),a.createElement("p",null,"The mapper function is a decorator. it gets the argument func, which really is the wrapped function (the decorated function). Then it has an inner function, which gets the arguments of the wrapped function. In our case it is a list of strings. The inner function loops on the list, and uses the camelcase function on each string. Finally the mapper returns the inner function (note that there are no parentheses () because we return the function and not executing it). Now when calling a camelcase on a list of strings, we're getting back a list of camel case strings that we got with the use of the decorator."),a.createElement(P.a,{variant:"info"},"Note: In this implementation, if we'd use this code on a regular string, it will break it down to letters, as string is also an iterable structure. We could check it in our wrapper, by examining the type of the input, but it is not recommended. It is recommended to stick to a strong typed function, and for different type, to use a different function."),a.createElement("h3",null,"Decorators with arguments:"),a.createElement("p",null,"Let's say now that we want our decorator to be able to get arguments. For example, we have a function that generates random values out of a given list:"),a.createElement(C,{language:"python",code:"import random\n\n\ndef random_odd_digit():\n    return random.choice([1, 3, 5, 7, 9])\n\nprint(random_odd_digit())\n\n>>> 7"}),a.createElement("p",null,"Now we want to decorate that function with a function that takes this random value and calculates a power of 2 and prints it out. We will use a regular decorator as we saw previously for that:"),a.createElement(C,{language:"python",code:"import random\n \ndef power_of_2(func):\n    def inner():\n        return func() ** 2\n    return inner\n  \n@power_of_2\ndef random_odd_digit():\n    return random.choice([1, 3, 5, 7, 9])\n  \nprint(random_odd_digit()) \n  \n>>> 25"}),a.createElement("p",null,"Lastly, we want to be able to state to the decorator which power should we be using as an argument. To do that we add another level of abstraction as following"),a.createElement(C,{language:"python",code:"import random\n \ndef power_of(exponent):\n    def decorator(func):\n        def inner():\n            return func() ** exponent\n        return inner\n    return decorator\n  \n@power_of(3)\ndef random_odd_digit():\n    return random.choice([1, 3, 5, 7, 9])\n  \nprint(random_odd_digit())\n  \n>>> 343"}),a.createElement("p",null,"Note that the function power_of actually returns a decorator, which is the one that decorates random_odd_digit() and it uses the decorator argument exponent, within the nested function of the decorator (inner())"),a.createElement("h3",null,"Debugging decorators"),a.createElement("p",null,"One thing that we should remember is that when using decorators, basically the inner function of the decorator replaces the decorated function, including its name, docstrings, etc... To avoid that, and keep things within the correct context, we should use wraps module out of the functools package. Going back to our second example to demonstrate it"),a.createElement(C,{language:"python",code:'def mapper(func):\n    def inner(list_of_strings):\n        """ this is inner """\n        return [func(value) for value in list_of_strings]\n    return inner\n \n@mapper\ndef camelcase(s: str) -> str:\n    """ turns string_like to StringLike """\n    return \'\'.join([word.capitalize() for word in s.split(\'_\')])\n \nprint(camelcase.__name__)\nprint(camelcase.__doc__)\n \n>>> inner\n>>> this is inner'}),a.createElement("p",null,"So, camelcase is replaced with the properties of inner(). let's now use wraps decorator:"),a.createElement(C,{language:"python",code:'from functools import wraps\n\ndef mapper(func):\n    @wraps(func)\n    def inner(list_of_strings):\n        """ this is inner """\n        return [func(value) for value in list_of_strings]\n\n    return inner\n\n@mapper\ndef camelcase(s: str) -> str:\n    """ turns string_like to StringLike """\n    return \'\'.join([word.capitalize() for word in s.split(\'_\')])\n\nprint(camelcase.__name__)\nprint(camelcase.__doc__)\n\n>>> camelcase\n>>> turns string_like to StringLike'}),a.createElement("p",null,"As already stated, it is also important for debugging. In this example the arguments are explicitely defined in the function body, but when working with tests or calls from outer scopes, it is not the case, and wraps must be used for proper debugging."),a.createElement("h3",null,"Decorating a function with a class:"),a.createElement("p",null,'One handy feature of decorating a function with a class is memory. A class decorator can "remember" the instances that happened along the execution of the function, which can be later used in different ways. Defining a decorator as a class should have a callable dunder (__call__).'),a.createElement(C,{language:"python",code:"import random\n \nclass Elephant:\n    def __init__(self, fnc):\n        self._fnc = fnc\n  \n    def __call__(self):\n        return self._fnc()\n  \n@Elephant\ndef random_odd_digit():\n    return random.choice([1, 3, 5, 7, 9])\n  \n>>> print(random_odd_digit())\n9"}),a.createElement("p",null,"The decorator passes the function to the constructor (__init__), and then it executes it, each time this function is called. Now, let's extend the functionality of the class, to use its built-in features for our purpose."),a.createElement(C,{language:"python",code:"import random\n \nclass Elephant:\n    def __init__(self, fnc):\n        self._fnc = fnc\n        self._memory = []\n  \n    def __call__(self):\n        retval = self._fnc()\n        self._memory.append(retval)\n        return retval\n  \n    def memory(self):\n        return self._memory\n  \n@Elephant\ndef random_odd_digit():\n    return random.choice([1, 3, 5, 7, 9])\n  \n>>> print(random_odd_digit())\n9\n>>> print(random_odd_digit())\n3\n>>> print(random_odd_digit())\n1\n>>> print(random_odd_digit())\n9\n>>> print(random_odd_digit.memory())\n[9, 3, 1, 9]"}),a.createElement("p",null,"So what happened here?"),a.createElement("ul",null,a.createElement("li",null,"We added a new property - _memory which is an empty list"),a.createElement("li",null,"We changed the __call__ method, by appending each call to _fnc to the _memory list"),a.createElement("li",null,"We added a memory() method which returns the _memory list")),a.createElement("p",null,"Basically this new list, which is a property of the decorator class, remembers all the previous calls of this function. It can be useful for example when using a mock.patch decorator for testing."),a.createElement("h3",null,"Decorating a class:"),a.createElement("p",null,"Decorators are not limited to acting on functions, they can act on classes as well. Say for example we have a class that does a lot of very important stuff and we want to time everything it does."),a.createElement(C,{language:"python",code:'def time_this(fnc):\n    def new_function():\n        import datetime\n        before = datetime.datetime.now()\n        x = fnc()\n        after = datetime.datetime.now()\n        print("Elapsed Time = {0}".format(after-before))\n        return x\n    return new_function\n \n \nclass ImportantStuff(object):\n    @time_this\n    def do_stuff_1(self):\n        ...\n    @time_this\n    def do_stuff_2(self):\n        ...\n    @time_this\n    def do_stuff_3(self):\n        ...'}),a.createElement("p",null,"That would work just fine. But it's quite a few extra lines of code within the class. And what if we write some more class methods and forget to decorate one of them? What if we decide we dont want to time the class any more? There is definitely space for human error here. It would be much nicer to re-write the class like this:"),a.createElement(C,{language:"python",code:"@time_all_class_methods\nclass ImportantStuff:\n    def do_stuff_1(self):\n        ...\n    def do_stuff_2(self):\n        ...\n    def do_stuff_3(self):\n        ..."}),a.createElement("p",null,"That code is equivalent to:"),a.createElement(C,{language:"python",code:"class ImportantStuff:\n    def do_stuff_1(self):\n        ...\n    def do_stuff_2(self):\n        ...\n    def do_stuff_3(self):\n        ...\n         \nImportantStuff = time_all_class_methods(ImportantStuff)"}),a.createElement("p",null,"So how would time_all_class_methods work? Firstly, we know it needs to take in a class as an argument, and return a class. We also know that the functions of the returned class should look the same as the functions of the original ImportantStuff class. That is, we still want to be able to do our important stuff, we just want to time it as well. And here is how we will do it. First, we will use the same time_this function as previously"),a.createElement(C,{language:"python",code:'def time_this(original_function):\n    print("decorating")\n    def new_function(*args,**kwargs):\n        print("starting timer")\n        import datetime\n        before = datetime.datetime.now()\n        x = original_function(*args,**kwargs)\n        after = datetime.datetime.now()\n        print("Elapsed Time = {0}".format(after-before))\n        return x\n    return new_function'}),a.createElement(P.a,{variant:"info"},"Note the usage of args and kwargs here. Remember that a function should be able to be used with its arguments, and that's why we have to handle it in our decorator"),a.createElement("p",null,"Second, we define a new function, that handles a class"),a.createElement(C,{language:"python",code:'def time_all_class_methods(Cls):\n    class NewCls(object):\n        def __init__(self, *args, **kwargs):\n            self.oInstance = Cls(*args, **kwargs)\n        def __getattribute__(self, s):\n            """\n            this is called whenever any attribute of a NewCls object is accessed. This function first tries to\n            get the attribute off NewCls. If it fails then it tries to fetch the attribute from self.oInstance (an\n            instance of the decorated class). If it manages to fetch the attribute from self.oInstance, and\n            the attribute is an instance method then \'time_this\' is applied.\n            """\n            try:\n                x = super(NewCls,self).__getattribute__(s)\n            except AttributeError:\n                pass\n            else:\n                return x\n            x = self.oInstance.__getattribute__(s)\n            if type(x) == type(self.__init__):  # it is an instance method\n                return time_this(x)  # this is equivalent of just decorating the method with time_this\n            else:\n                return x\n    return NewCls'}),a.createElement("p",null,"Lastly, we try it on a simple class with a timeout:"),a.createElement(C,{language:"python",code:'@time_all_class_methods\nclass Foo(object):\n    def a(self):\n        print("entering a")\n        import time\n        time.sleep(3)\n        print("exiting a")\n \n>>> oF = Foo()\n>>> oF.a()\n \n \ndecorating\nstarting timer\nentering a\nexiting a\nElapsed Time = 0:00:03.000347'}))},O=function(){return a.createElement(j.a,null,a.createElement("h2",null,"Intro"),a.createElement("p",null,"It is very important to understand the dependencies management and environments management in Python. There are general purpose installers as anaconda and miniconda (https://conda.io/miniconda.html). However when developing production products, it is generally a good idea to bring the working environment as close as possible to production. That is done by working with virtual environments."),a.createElement("h3",null,"venv:"),a.createElement("p",null,"The ",a.createElement("a",{href:"https://docs.python.org/3.6/library/venv.html#module-venv",style:{color:"blue"}},"venv")," module provides support for creating lightweight \u201cvirtual environments\u201d with their own site directories, optionally isolated from system site directories. Each virtual environment has its own Python binary (allowing creation of environments with various Python versions) and can have its own independent set of installed Python packages in its site directories. venv package is built-in in Python."),a.createElement("h3",null,"Creating a virtual environment"),a.createElement("p",null,"To create a new project, we simply use this command from within a terminal"),a.createElement(C,{language:"bash",code:"# python -m venv /path/to/folder/\n# for example\n \n$python -m venv ./practice-venv"}),a.createElement("p",null,"The new environment is created and the content of the folder contains Include, Lib and Scripts folders and a pyvenv.cfg file"),a.createElement(C,{language:"bash",code:"$ ls\nInclude/  Lib/  pyvenv.cfg  Scripts/"}),a.createElement("p",null,"from this point it will be more convenient to work within the IDE."),a.createElement("h3",null,"Selecting the interpreter and activating"),a.createElement("p",null,"To start using the virtual environment one need to select the interpreter and to activate it as following (note: the procedure refers to Pycharm):"),a.createElement("ul",null,a.createElement("li",null,"ctrl+alt+s to open settings"),a.createElement("li",null,"search for interpreter"),a.createElement("li",null,"add new interpreter that is under Scripts/python.exe")),a.createElement("p",null,"To activate the virtual environment:"),a.createElement("ul",null,a.createElement("li",null,"ctrl+alt+s to open settings"),a.createElement("li",null,"tools \u2192 Terminal \u2192 Shell path"),a.createElement("li",null,'Type in: "cmd.exe" /k ""path to \\Scripts\\activate.bat""'),a.createElement("li",null,"close the terminal and open it again. it should now be marked as (local environment name)")),a.createElement("p",null,"test:"),a.createElement(C,{language:"bash",code:"pip list\n>>>\nPackage    Version\n---------- -------\npip        10.0.1\nsetuptools 39.0.1\n \nwhere python.exe\n>>>\npath to virtual env/Scripts/python.exe"}),a.createElement("h3",null,"Installing Packages"),a.createElement("p",null,"When working on a local virtual environment, all the packages will be installed locally and will not interfere other projects, or the general installers (miniconda). To install a package just use pip install"),a.createElement(C,{language:"python",code:"# pip install <package name>\npip install numpy\n \n \n# to install a specific version, just specify it as following\npip install requests==2.18.4"}),a.createElement("h3",null,"Using requirements.txt file"),a.createElement("p",null,"Instead of installing packages individually, pip allows you to declare all dependencies in a Requirements File. For example you could create a requirements.txt file containing:"),a.createElement(P.a,{variant:"info"},a.createElement(P.a.Heading,null,"requirements.txt:"),a.createElement("p",null,"requests==2.18.4"),a.createElement("p",null,"google-auth==1.1.0")),";",a.createElement("p",null,"And tell pip to install all of the packages in this file using the -r flag:"),a.createElement(C,{language:"python",code:"pip install -r requirements.txt"}),a.createElement("h3",null,"Freezing dependencies"),a.createElement("p",null,"Pip can export a list of all installed packages and their versions using the freeze command:"),a.createElement(C,{language:"python",code:"pip freeze"}),a.createElement("p",null,"which will output a list of package specifiers to the terminal, and later should be copied to the requirement.txt file"),a.createElement(P.a,{variant:"info"},a.createElement(P.a.Heading,null,"requirements.txt:"),a.createElement("p",null,"cachetools==2.0.1"),a.createElement("p",null,"certifi==2017.7.27.1"),a.createElement("p",null,"chardet==3.0.4"),a.createElement("p",null,"google-auth==1.1.1"),a.createElement("p",null,"idna==2.6"),a.createElement("p",null,"pyasn1==0.3.6"),a.createElement("p",null,"pyasn1-modules==0.1.4"),a.createElement("p",null,"requests==2.18.4"),a.createElement("p",null,"rsa==3.4.2"),a.createElement("p",null,"six==1.11.0"),a.createElement("p",null,"urllib3==1.22")),a.createElement("p",null,"This is useful for creating requirements file that can re-create the exact versions of all packages installed in the local environment A lot more material can be found here: ",a.createElement("a",{href:"https://packaging.python.org/key_projects/#virtualenv"},"https://packaging.python.org/key_projects/#virtualenv")))},W=function(){return a.createElement(j.a,null,a.createElement("h2",null,"Intro"),a.createElement("p",null,'Dunder stands for double-underscore. Dunders are also known as special methods or magical methods. In Python, special methods are a set of predefined methods you can use to enrich your classes. They are easy to recognize because they start and end with double underscores, for example __init__ or __str__. Every object in Python has its own dunders, and knowing how to manipulate and use them, will make your objects more "Pythonic", the code more readable and easy to use and maintain.'),a.createElement("p",null,"First, to list all available dunders of an object, use the dir() command"),a.createElement(C,{language:"python",code:"# dir on a list\ndir([])\n\n>>> ['__repr__', '__hash__', '__getattribute__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__iter__', '__init__', '__len__', '__getitem__', '__setitem__', '__delitem__', '__add__', '__mul__', '__rmul__', '__contains__', '__iadd__', '__imul__', '__new__', '__reversed__', '__sizeof__', 'clear', 'copy', 'append', 'insert', 'extend', 'pop', 'remove', 'index', 'count', 'reverse', 'sort', '__doc__', '__str__', '__setattr__', '__delattr__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__dir__', '__class__']\n\n# dir on a string\ndir('')\n>>> ['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']\n\n# dir on a new class\nclass NewObj(object):\n    pass\n                         \nn = NewObj()\ndir(n)\n\n>>> ['__module__', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__init__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__']"}),a.createElement("p",null,"This example demonstrates that a built in type (list) has plenty of its own dunders, and also a new class, has quite a few of them as well. In the next examples we will go through the most notable and used dunders in Python."),a.createElement("h3",null,"Object constructor: __init__"),a.createElement("p",null,"The plain known constructor is actually a special method: __init__ Rarely you will see classes without this object"),a.createElement(C,{language:"python",code:'class Account:\n"""A simple account class"""\n\ndef __init__(self, owner, amount=0):\n"""\nThis is the constructor that lets us create\nobjects from this class\n"""\n    self.owner = owner\n    self.amount = amount\n    self._transactions = []'}),a.createElement("p",null,"In this example we initialize a few properties of the Account class with the inputs that are passed in the class initialization. Note the self._transactions property. The convention in Python is that an internal property or method, will be marked with a single underscore (opposed to dunders). These methods and properties are still accessible from outside but a good programming practice is to use them only inside the scope where they are defined. The instance of the class will be created like this:"),a.createElement(C,{language:"python",code:">>> acc = Account('Alice')  # default amount = 0\n>>> acc = Account('Bob', 10)"}),a.createElement("h3",null,"Object Name: __name__"),a.createElement("p",null,"The name of the object is by default the name of the class, but it can be changed programatically. The most wide known use of __name__ is as a runner within the module:"),a.createElement(C,{language:"python",code:"def main():\nacc = Account('Alice')  # default amount = 0\nacc = Account('Bob', 10)\n\nprint(Account.__name__)\n\nif __name__ == '__main__':\n    main()"}),a.createElement("p",null,"this usage basically lets the programmer to run the module itself, which can be convenient during development. Note - a good programming practice for production code is not to use this pattern. A better way is to run the module from its testing module"),a.createElement("h3",null,"Object Representation: __str__, __repr__"),a.createElement("p",null,"A common way to get meaningful representation and printing of an object is to use __str__ and __repr__. __str__ will print a specified message when using print(obj) or str(obj) and __repr__ will be used when using repr(obj)."),a.createElement("p",null,"Let's add these two special methods to the Account class"),a.createElement(C,{language:"python",code:"class Account:\n# ... (see above)\n\ndef __repr__(self):\n    return 'Account({!r}, {!r})'.format(self.owner, self.amount)\n                         \ndef __str__(self):\n    return 'Account of {} with starting amount: {}'.format(self.owner, self.amount)\n                         \n>>> str(acc)\n'Account of bob with starting amount: 10'\n                         \n>>> print(acc)\n\"Account of bob with starting amount: 10\"\n                         \n>>> repr(acc)\n\"Account('bob', 10)\""}),a.createElement("h3",null,"Iteration special methods: __len__, __getitem__"),a.createElement("p",null,"These special methods are used to iterate through the objects in the class. In the __init__ method we defined the _transaction property as a list. Now it's time to use it."),a.createElement("p",null,"We're defining four new methods - two special methods __len__ and __getitem__, add_transaction method which stores each transaction in the ._transaction list and the property balance."),a.createElement(C,{language:"python",code:"class Account:\n# ... (see above)\n                         \ndef __len__(self):\n    return len(self._transactions)\n                         \ndef __getitem__(self, position):\n    return self._transactions[position]\n                         \ndef add_transaction(self, amount):\n    if not isinstance(amount, int):\n        raise ValueError('please use int for amount')\n    self._transactions.append(amount)\n                         \n@property\ndef balance(self):\n    return self.amount + sum(self._transactions)\n                        \n>>> acc = Account('bob', 10)                        \n>>> acc.add_transaction(20)\n>>> acc.add_transaction(-10)\n>>> acc.add_transaction(50)\n>>> acc.add_transaction(-20)\n>>> acc.add_transaction(30)\n>>> acc.balance\n80\n>>> len(acc)\n5\n>>> for t in acc:\n...    print(t)\n20\n-10\n50\n-20\n30"}),a.createElement("p",null,"special method __len__ returns the specified value when using len(obj). If you'd try to use len(obj) on our Account class without defining __len__, it would raise a TypeError. special method __getitem__ allows to iterate through an object as shown in the example. It is a very convenient and important special method to use."),a.createElement("h3",null,"Comparing operators: __eq__, __lt__"),a.createElement("p",null,"What can you do to compare the objects you create? A logical way to compare two accounts object is to say who has a higher balance. To do that we need to implement all the comparison dunders. Instead of doing that, we will only implement two dunders (equal - __eq__ and less than __lt__) and all the others will fall in place thanks to the wonders of the functools.total_ordering decorator."),a.createElement("p",null,"Changing the class a little:"),a.createElement(C,{language:"python",code:"from functools import total_ordering\n                         \n@total_ordering\nclass Account:\n\n# ... (see above)\n                          \ndef __eq__(self, other):\n    return self.balance == other.balance\n                          \ndef __lt__(self, other):\n    return self.balance < other.balance"}),a.createElement("p",null,"So, introducing these two new methods allow us to compare the balances of the accounts:"),a.createElement(C,{language:"python",code:"acc1 = Account('elza', 10)\nacc2 = Account('tim', 100)\n                         \n                         \n>>> acc2 > acc1\nTrue\n                         \n>>> acc2 < acc1\nFalse\n                         \n>>> acc2 == acc1\nFalse"}),a.createElement("p",null,'Decorators is a "heavy" topic in Python, and we will deal with it in the next blogs. However just to make it short, a decorator is a wrapper of a function, a method or a class, alternating or adding to its original functionalities. In our case, this decorator makes it possible to avoid defining all other comparison dunders, which can be tedious, and still to get the comparison functionality.'),a.createElement("h3",null,"Adding operator: __add__"),a.createElement("p",null,"A very common operator in Python is +. It can add numbers, strings and other objects. The wonders of '+' are due to the __add__ special method. In the known objects of int and str, they are implemented to sum numbers and concatenate strings. In our Account object, we can use it to merge two accounts. Adding the __add__ special method to our class:"),a.createElement(C,{language:"python",code:"def __add__(self, other):\nowner = self.owner + ' & ' + other.owner\nstart_amount = self.balance + other.balance\nreturn Account(owner, start_amount)\n                                                \n>>> acc3 = acc1 + acc2\n>>> print(acc3.balance)\n>>> print(acc3.owner)\n110\nelza & tim"}),a.createElement("h3",null,"Callable objects: __call__"),a.createElement("p",null,"This special method makes an object callable. Which means it can be used as a function. In the case of the Account object we can use the __call__ method to make a nice printout of the account, but it really can be anything we want."),a.createElement(C,{language:"python",code:"class Account:\n# ... (see above)\n                         \ndef __call__(self):\n    print('Start amount: {}'.format(self.amount))\n    print('Transactions: ')\n    for transaction in self:\n        print(transaction)\n    print('\nBalance: {}'.format(self.balance))\n                        \n>>> acc3()\nStart amount: 110\nTransactions:\n                         \nBalance: 110"}),a.createElement("p",null,"Note: often it wouldn't be a good programming practice to use the __call__ method this way. It would be much better to have a regular method dealing with the printout explicitly. One good use case for a callable method, is by using a mock patch for testing functions generating random values"),a.createElement("h3",null,"Context manager support: __enter__, __exit__"),a.createElement("p",null,'This dunder is a little more advanced than the previous ones. We will introduce what should be added to the object to make it used with the "with" statement. First - a context manager is a simple interface that your object needs to follow so it can be used with the with statement. Basically all you need to do is add __enter__ and __exit__ methods to an object if you want it to function as a context manager. We will demonstrate that in our Account class, as a rollback functionality, so that if too much money was asked to be withdrawn, it will cancel the transaction request.'),a.createElement("p",null,"Adding these 2 new methods to our class and a helper function (outside of the class):"),a.createElement(C,{language:"python",code:"class Account:\n# ... (see above)\n                         \ndef __enter__(self):\n    print('ENTER WITH: Making backup of transactions for rollback')\n    self._copy_transactions = list(self._transactions)\n    return self\n                         \ndef __exit__(self, exc_type, exc_val, exc_tb):\n    print('EXIT WITH:', end=' ')\n    if exc_type:\n        self._transactions = self._copy_transactions\n        print('Rolling back to previous transactions')\n        print('Transaction resulted in {} ({})'.format(\n            exc_type.__name__, exc_val))\n        else:\n            print('Transaction OK')\n                         \n                         \ndef validate_transaction(acc, amount_to_add):\n    with acc as a:\n        print('Adding {} to account'.format(amount_to_add))\n        a.add_transaction(amount_to_add)\n        print('New balance would be: {}'.format(a.balance))\n        if a.balance < 0:\n            raise ValueError('sorry cannot go in debt!')           \n                        \n                        \n>>> acc4 = Account('Danny', 10)\n>>> validate_transaction(acc4, 30)\n                         \n                         \nENTER WITH: Making backup of transactions for rollback\nAdding 30 to account\nNew balance would be: 40\nEXIT WITH: Transaction OK                        \n                         \n>>> validate_transaction(acc4, -60)\n                         \nENTER WITH: Making backup of transactions for rollback\nAdding -60 to account\nNew balance would be: -20\nEXIT WITH: Rolling back to previous transactions\nTransaction resulted in ValueError (sorry cannot go in debt!)"}),a.createElement("p",null,"Ok, so what happened here? First, we defined two special methods. The __enter__ method is executed on the beginning of the 'with' statement and the __exit__ statement is executed at the end of the 'with' statement. In the __exit__ method, the signature states that it could end with an exception or without it. If it will end without an exception, we will see a statement \"Transaction OK\", otherwise it will go to a rollback flow and print the rollback statements. The helper function just generates an exception is the balance becomes negative, and that is executed via the __exit__ method."),a.createElement("h3",null,"Summary:"),a.createElement("p",null,'There are many more dunders to check out. Some useful some not so much. This blog should give you the confidence to go for it and investigate, to make your classes more elegant, more "Pythonic" and more useful.'))},q=function(){return a.createElement(j.a,null,a.createElement("h2",null,"Intro"),a.createElement("p",null,"First class functions and closures are an important concept in Python. As we know, everything in Python is an object with regular and special methods. First order functions and closures are also an important concepts for explaining and using decorators, which we will explain in the upcoming blogs."),a.createElement("h3",null,"First class functions"),a.createElement("p",null,"First class objects in a language may be stored in data structures, passed as arguments, or used in control structures. A programming language is said to support first-class functions if it treats functions as first-class objects. Python supports the concept of First Class functions."),a.createElement("p",null,"Basically, a first class function is a function that can be passed as an argument, stored in a variable, returned from a function and stored in a data structure (list, dict,...)"),a.createElement("p",null,a.createElement("strong",null,"Example 1:")),a.createElement(C,{language:"python",code:"def shout(text):\n    return text.upper()\n \n \nprint(shout('Hello'))\n>>> HELLO\n\nyell = shout\nprint(yell('Hello'))\n>>> HELLO\n\nprint(type(yell))\n>>> <class 'function'>\n"}),a.createElement("p",null,"In this example, we assign the function object 'shout' to a variable 'yell', and use the variable 'yell' with an argument 'Hello'. The type of the variable 'yell' is a class function. Note that the function is assigned without brackets ()"),a.createElement("p",null,a.createElement("strong",null,"Example 2:")),a.createElement(C,{language:"python",code:'def shout(text):\n    return text.upper()\n \n \ndef whisper(text):\n    return text.lower()\n \n \ndef greet(func):\n    # storing the function in a variable\n    greeting = func("Hi, I am created by a function passed as an argument.")\n    print(greeting)\n \n \ngreet(shout)\n>>> HI, I AM CREATED BY A FUNCTION PASSED AS AN ARGUMENT.\n\ngreet(whisper)\n>>> hi, i am created by a function passed as an argument.\n'}),a.createElement("p",null,"In this example, we're using the first class functions as arguments to other functions. We created two functions 'whisper' and 'shout', and we call the greet function passing in one of the functions we created. The whisper function will turn the input string to lower letters and the shout function will turn it to capital letters."),a.createElement("p",null,a.createElement("strong",null,"Example 3")),a.createElement("p",null,"In this example we implement a mapping functionality by ourselves by passing a function into a my_map function and implementing it for all elements in the list."),a.createElement(C,{language:"python",code:"from typing import List, Callable, Union\nNumericType = Union[int, float]\n \ndef square(x: NumericType) -> NumericType:\n    return x * x\n \ndef my_map(func: Callable[[NumericType], NumericType], arg_list: List) -> List:\n    result = list()\n    for i in arg_list:\n        result.append(func(i))\n    return result\n \nnum = [1, 2, 3, 4, 5]\nsquare_num = my_map(square, num)\n\nprint(square_num)\n>>> [1, 4, 9, 16, 25]\n"}),a.createElement("p",null,"Note the usage of typing here. Every function clearly defines its inputs and outputs and their types. This is a good programming practice, although not enforced in Python, being a strongly dynamic typed language. For stating a function as an input of an output, use:"),a.createElement(C,{language:"python",code:"Callable[[<input types>], <output types>]"}),a.createElement("p",null,a.createElement("strong",null,"Example 4:")),a.createElement("p",null,"In this example we will demonstrate the last and possibly the most confusing part of first class functions - returning a function."),a.createElement(C,{language:"python",code:"def html_tag(tag: str) -> Callable[[str], None]:\n    def wrap_text(msg: str) -> None:\n        print(\"<{0}>{1}</{0}>\".format(tag, msg))\n \n    return wrap_text\n \nprint_h1 = html_tag('h1')\n\nprint_h1(\"I'm headline 1\")\n>>> <h1>I'm headline 1</h1>\n\nprint_h1(\"I'm headline 2\")\n>>> <h1>I'm headline 2</h1>\n\nprint_div = html_tag('div')\n\nprint_div(\"I'm div 1\")\n>>> <div>I'm div 1</div>\n\nprint_div(\"I'm div 2\")\n>>> <div>I'm div 2</div>\n"}),a.createElement("p",null,"This function creates a wrapper of a text with HTML tags. We create a function object print_h1 which will wrap each message it will get with the correct h1 tags on both sides. This example actually demonstrates a closure, which will be discussed next. Note - the usage of .format in a string. This is very useful for creating dynamic strings and messages."),a.createElement("h3",null,"Closures"),a.createElement("p",null,"Closures in their most basic form are nested functions that return function objects. A better way to describe closures is to say that it is a record that stores a function together with an environment: a mapping associating each free variable of the function (variables that are used locally, but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created."),a.createElement("p",null,"A classical use for closures is as callback functions. It will also be a useful for understanding and using decorators."),a.createElement("p",null,a.createElement("strong",null,"Example 1:")),a.createElement("p",null,"Let's examine a simple example describing closures:"),a.createElement(C,{language:"python",code:"def outer_function(text):\n    def inner_function():\n        print(text)\n \n    return inner_function\n \nfunc1 = outer_function('Hey!')\nfunc1()\n\n>>> Hey!\n"}),a.createElement("p",null,"In this example we're using a first class function - 'inner_function' and return it. A small addition to the first class functions concept, is that the inner function is aware of the outer function variables ('text' in our case) and is using it to print a message. Later on 'func1' will always \"remember\" that it was created with a string 'Hey!' and will be able to fetch it."),a.createElement("p",null,"Note - we are returning the function without parentheses"),a.createElement("p",null,a.createElement("strong",null,"Example 2:")),a.createElement("p",null,"A very nice example to demonstrate closures is with the help of the logging module:"),a.createElement(C,{language:"python",code:"import logging\n \n logging.basicConfig(filename='example.log', level=logging.INFO)\n  \n def logger(func):\n     def log_func(*args):\n         logging.info(\n             'Running \"{}\" with arguments {}'.format(func.__name__, args))\n         print(func(*args))\n  \n     return log_func\n  \n def add(x, y):\n     return x + y\n  \n def sub(x, y):\n     return x - y\n  \n add_logger = logger(add)\n sub_logger = logger(sub)\n  \n add_logger(3, 3)\n >>> 6\n\n add_logger(4, 5)\n >>> 9\n\n sub_logger(10, 5)\n >>> 5\n\n sub_logger(20, 10)\n >>> 10\n "}),a.createElement("p",null,"In this example we can see the logger wrapper over any given input function. The output in the python console shows just the results of the functions and the log text file shows the whole message."),a.createElement(C,{language:"python",code:'# In the log:\nINFO:root:Running "add" with arguments (3, 3)\nINFO:root:Running "add" with arguments (4, 5)\nINFO:root:Running "sub" with arguments (10, 5)\nINFO:root:Running "sub" with arguments (20, 10)'}),a.createElement("h3",null,"Sumary:"),a.createElement("p",null,"In this blog we covered the topic of first order functions and closures. First order functions are function objects that are allowed to be passed as arguments and stored in different data structures. Closure is a structure of functions that return a function. The usages of these concepts are different, and in Python we will find them mostly as wrappers in general  and decorators in particular."))},z=function(){return a.createElement(j.a,{className:"blog-container"},a.createElement("h2",null,"Python Blog: Enhance your functions"),a.createElement("p",null,"Functions are the most basic and important components in our programs. There are many interesting features and capabilities provided in Python, to make our functions better and less prone to errors. We will review some of these features in this blog, and some next week. This week we will look at keyword arguments at function input - how to use them and why are they a good practice and how can we enforce using them. In addition we will check exception handling and the usage of generators instead of lists as function outputs."),a.createElement("h3",null,"Provide optional behavior with keyword arguments:"),a.createElement("p",null,"In python we can pass arguments to a function by position or with a keyword. Say we have this simple function taking 2 arguments and calculating the remainder of a number:"),a.createElement(C,{language:"python",code:"def remainder(number, divisor):\n    return number % divisor\n \nprint(remainder(20, 7))\n \n>>>\n6\n"}),a.createElement("p",null,"Although it is a simple case, it might require the user, to check the function code to understand which argument is responsible for what. It will be much clearer to use keyword arguments, and it is also not required to keep their positions, so in case of an interface change in the future, the functionality will not break."),a.createElement(C,{language:"python",code:"print(remainder(number=30, divisor=7))\nprint(remainder(divisor=7, number=30))\n \n>>>\n2\n2\n"}),a.createElement("h3",null,"Enforce clarity with keyword-only arguments"),a.createElement("p",null,"As we have seen, it is very convenient to use keywords in function arguments. The nice thing is that we can enforce that. Let's say that we have a function with a couple of boolean flags as arguments:"),a.createElement(C,{language:"python",code:"def some_function(a, b, flag_1, flag_2):\n    pass\n \n \nsome_function(5, 10, True, False)\n"}),a.createElement("p",null,"While a and b, might be easy for the user to understand from an appropriate naming and context, remembering the order of the flags could be challenging. We can enforce the usage of some of the arguments by keyword only by using an asterix symbol between the positional arguments and keyword arguments. If the user ignores it, a TypeError will be raised."),a.createElement(C,{language:"python",code:"def some_function_with_kw(a, b, *, flag_1, flag_2):\n   pass\n \n# wrong way\nsome_function_with_kw(5, 10, True, False)\n \n \n# right way\nsome_function_with_kw(5, 10, flag_2=True, flag_1=False)\n \n>>>\nTypeError: some_function_with_kw() takes 2 positional arguments but 4 were given\n"}),a.createElement("h3",null,"Prefer exceptions to returning None:"),a.createElement("p",null,"Functions that return None to indicate special meaning are error prone, because __bool__ check on None is similar to __bool__ check on 0, empty string and empty list. For example, say we want to create a function that divides 2 numbers, and we want to avoid raising an error, when trying to divide by zero, by catching the ZeroDivisionError and returning a None. In that case we could introduce this error:"),a.createElement(C,{language:"python",code:"def divide(a,b):\n    try:\n        return a/b\n    except ZeroDivisionError:\n        return None\n \n# case 1\nx, y = 3, 0\nresult = divide(x, y)\nif not result:\n    print('Invalid inputs')\n \n# case 2\nx, y = 0, 3\nresult = divide(x, y)\nif not result:\n    print('Invalid inputs')\n \n \n>>>\nInvalid inputs\nInvalid inputs\n"}),a.createElement("p",null,"As can be seen, in both cases, we print 'Invalid inputs' although in case 2 the inputs are correct. A suggested solution, is to leave handling the errors to the callers, and raise an exception from within the function:"),a.createElement(C,{language:"python",code:"def divide(a,b):\n    try:\n        return a/b\n    except ZeroDivisionError as e:\n        raise ValueError('Invalid inputs') from e\n \n# case 1\nx, y = 3, 0\ntry:\n    result = divide(x, y)\n    print('result: ', result)\nexcept ValueError:\n    print('Invalid inputs')\n \n# case 2\nx, y = 0, 3\ntry:\n    result = divide(x, y)\n    print('result: ', result)\nexcept ValueError:\n    print('Invalid inputs')\n \n \n>>>\nInvalid inputs\nresult:  0.0\n"}),a.createElement("h3",null,"Consider returning generators rather than lists:"),a.createElement("p",null,"In many cases we write functions that return lists. There are two main problems with these functions: noisy code and a risk of running into memory issues for large data sets. Here is an example of a simple function taking in text and returning the index of the first letter of each word."),a.createElement(C,{language:"python",code:'def index_of_words(text):\n    result = []\n    if text:\n        result.append(0)\n    for ind, letter in enumerate(text):\n        if letter == " ":\n            result.append(ind + 1)\n \n    return result\n \ntext = "Hello, my name is John"\nprint(index_of_words(text))\n \n>>>\n[0, 7, 10, 15, 18]\n'}),a.createElement("p",null,'In this rather simple function, there is quite some redundancy. In addition, as mentioned above, for a large input text, the program could crash for insufficient memory. A very practical and "Pythonic" solution is to use generators. We will have a separate blog topic regarding generators and iterators, but in short, generators are functions that use yield expressions (instead of return). They don\'t actually run, but return an iterator, which later can be used within any object by using the __iter__ and __next__ dunders. Here is an example for the same functions written with generators:'),a.createElement(C,{language:"csv",code:'def index_of_words_iter(text):\n    if text:\n        yield 0\n    for ind, letter in enumerate(text):\n        if letter == " ":\n            yield ind + 1\n \ntext = "Hello, my name is John"\nprint(list(index_of_words_iter(text)))\n \n>>>\n[0, 7, 10, 15, 18]\n'}),a.createElement("p",null,"The implementation is cleaner and is memory efficient. The list() operator transforms the generator expression back to the same result, but it can be used in many other ways."),a.createElement("p",null,"Note - when defining generators like this, the callers must be aware that the returned iterators are stateful and can't be reused. See example below."),a.createElement(C,{language:"python",code:'text = "Hello, my name is John"\nresults = index_of_words_iter(text)\nprint(list(results))\n \nprint("statefulness check:")\nprint(list(results))\n \n>>>\n[0, 7, 10, 15, 18]\nstatefulness check:\n[]\n'}),a.createElement("h3",null,"Be careful when iterating over lists"),a.createElement("p",null,"A very common function that we might use / write, is one that gets a list and iterates over its values. Let's say that we want to calculate the percentage of each item in an integer list, out of the sum of the list"),a.createElement(C,{language:"python",code:"def get_percentage(in_list):\n    return [100 * x / sum(in_list) for x in in_list]\n \nl = [20, 30, 15, 50, 54]\nprint(get_percentage(l))\n \n \n>>>\n[11.834319526627219, 17.75147928994083, 8.875739644970414, 29.585798816568047, 31.952662721893493]\n"}),a.createElement("p",null,"This function will work as many times as we'd like, as long as we keep the interface. Let's assume now that our function gets a generator. In this case we will get a surprising results:"),a.createElement(C,{language:"python",code:"def get_percentage(in_list):\n    return [100 * x / sum(in_list) for x in in_list]\n \ndef create_list():\n    lst = [20, 30, 15, 50, 54]\n    for x in lst:\n        yield x\n \nl = create_list()\nprint(get_percentage(list(l)))\nprint(get_percentage(list(l)))\n \n \n>>>\n[11.834319526627219, 17.75147928994083, 8.875739644970414, 29.585798816568047, 31.952662721893493]\n[]\n"}),a.createElement("p",null,"The cause of this behavior is that an iterator produces its results one time, and then it reaches a StopIteration exception. In that case, our function will not be able to distinguish if it is an exhausted iterator or an empty list. A problem is that we will not get any errors here, which might result in slippery bugs."),a.createElement("h3",null,"Reduce visual noise with positional arguments"),a.createElement("p",null,"A very common function that we might use / write, is one that gets a list and iterates over its values. Let's say that we want to calculate the percentage of each item in an integer list, out of the sum of the list"),a.createElement(C,{language:"python",code:"def get_percentage(in_list):\n    return [100 * x / sum(in_list) for x in in_list]\n \nl = [20, 30, 15, 50, 54]\nprint(get_percentage(l))\n \n \n>>>\n[11.834319526627219, 17.75147928994083, 8.875739644970414, 29.585798816568047, 31.952662721893493]\n"}),a.createElement("p",null,"This function will work as many times as we'd like, as long as we keep the interface."))},D=function(){return a.createElement(j.a,{className:"blog-container"},a.createElement("h3",null,"Iterators"),a.createElement("p",null,"Each object that can be used in a for loop is called an ",a.createElement("strong",null,"iterable object"),". Examples to such objects are lists, strings, dictionaries, sets, a text file, etc... A built-in iter() function, takes in a interable object and returns an iterator."),a.createElement(C,{language:"python",code:"a = [1, 2, 3]\nb = iter(a)\n \nprint(\"a is a: {}\".format(type(a)))\nprint(\"b is a: {}\".format(type(b)))\n>>>\na is a: <class 'list'>\nb is a: <class 'list_iterator'>\n"}),a.createElement("p",null,"So, every iterable object can be transformed to an iterator. An iterator is an object that returns the next element each time we use next() built-in function on it (behind the scenes it implements the dunder method __next__ of the iterator class), until there are no more elements in the iterable object and then a StopIteration exception is raised:"),a.createElement(C,{language:"python",code:"print(next(b))\nprint(next(b))\nprint(next(b))\nprint(next(b))\n \n>>>\n1\n2\n3\nStopIteration\n"}),a.createElement("p",null,"Each iterator must have an __iter__ dunder as well. This dunder is the one that is executed by the iter() built-in command. Generally the __iter__ dunder just returns the iterator itself. Below you can find an example to a simple iterator class that implements the built-in ",a.createElement("strong",null,"xrange()")," function, that gets a number n, and returns an iterator of all the inegers between 0 to n-1."),a.createElement(C,{language:"python",code:"class yrange:\n    def __init__(self, n):\n        self.i = 0\n        self.n = n\n \n    def __iter__(self):\n        return self\n \n    def __next__(self):\n        if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            raise StopIteration()\n \na = yrange(5)\nprint(sum(a))\n \n>>>\n10\n"}),a.createElement("p",null,"Note - there are many built-in functions in Python that accept iterators as arguments: sum(), max(), min(), list() and others"),a.createElement("p",null,"A known issue with iterators is that they are executed only once. After that, the function that will get an exhausted iterator will not be able to distinguish it from an empty list. There is a way to overcome it when creating iterators, by creating a helper class which effectively creates a duplication of the iterator without exhausting it:"),a.createElement(C,{language:"python",code:"class zrange:\n    def __init__(self, n):\n        self.n = n\n \n    def __iter__(self):\n        return zrange_iter(self.n)\n \nclass zrange_iter:\n    def __init__(self, n):\n        self.i = 0\n        self.n = n\n \n    def __iter__(self):\n        # Iterators are iterables too.\n        # Adding this functions to make them so.\n        return self\n \n    def __next__(self):\n        if self.i < self.n:\n            i = self.i\n            self.i += 1\n            return i\n        else:\n            raise StopIteration()\n"}),a.createElement("p",null,"Now, we are able to compare the regular yrange to the new zrange:"),a.createElement(C,{language:"python",code:"y = yrange(5)\nprint(list(y))\nprint(list(y))\n \nz = zrange(5)\nprint(list(z))\nprint(list(z))\n \n>>>\n[0, 1, 2, 3, 4]\n[]\n[0, 1, 2, 3, 4]\n[0, 1, 2, 3, 4]\n"}),a.createElement("p",null,"So, to sum up: iterators are objects that can be iterated upon. This object will return data by one element at a time. We can build our own iterators by implementing __next__ and __iter__ methods."),a.createElement("h3",null,"Generators"),a.createElement("p",null,"Generators is a way to create iterators. A generator is a function that produces a sequence of results instead of a single value in a regular function. Thus, a generator uses yield instead of return:"),a.createElement(C,{language:"python",code:"def yrange_gen(n):\n    i = 0\n    while i < n:\n        yield i\n        i += 1\n \ny = yrange_gen(5)\nprint(list(y))\n>>>\n[0, 1, 2, 3, 4]\n            "}),a.createElement("p",null,"So, instead of defining a whole class and implementing all the required methods, we can just use yield, and generate the same iterator. A generator works as following:"),a.createElement("ul",null,a.createElement("li",null,"Generator object is created (y = yrange_gen(5) in our example above)"),a.createElement("li",null,"When a next method is invoked for the first time, the generator function starts executing until it reaches the yield statement and returns the yielded value (yield i)"),a.createElement("li",null,'The following "next" method will continue from the next statement after yield (i += 1 and repeating the while loop)'),a.createElement("li",null,"The flow will continue until a StopIteration exception is raised")),a.createElement("p",null,"A very common way of using generators is instead of using large lists that can create memory issues. Always remember though that a generator can be executed only once until exhausted."),a.createElement("h3",null,"Generator Expressions"),a.createElement("p",null,"Generator expressions is the generator version of lists comprehension. They look identical except using regular parentheses () instead square ones []."),a.createElement(C,{language:"python",code:"a = (2*x for x in range(10))\nprint(a)\nprint(sum(a))\n \n \n>>>\n<generator object <genexpr> at 0x000001A181B2CAF0>\n90\n            "}),a.createElement("h3",null,"Summary:"),a.createElement("p",null,"In this blog we covered the iterators and generators concepts, the differences between them and when and how to use them properly. It can be confusing first, but it's worth the effort of getting used to and start using it in your functions."))},H=function(){return a.createElement(j.a,{className:"blog-container"},a.createElement("h2",null,"Intro"),a.createElement("p",null,"Collections module provides special enhancements for the regular containers in Python, such as dict, list, tuple and set. This blog will cover the ",a.createElement("i",null,"namedtuple()")," factory function that creates tuples with named fields."),a.createElement("h3",null,"problem description:"),a.createElement("p",null,"The standard tuple uses numerical indexes to access its members. This makes tuples convenient containers for simple uses. On the other hand, remembering which index should be used for each value can lead to errors, especially if the tuple has a lot of fields and is constructed far from where it is used. A namedtuple assigns field names to each member of the tuple, which makes it more readable and self-documenting code."),a.createElement(C,{language:"python",code:"# regular tuples\nbob = ('Bob', 30, 'male')\njane = ('Jane', 29, 'female')\n\nfor p in [bob, jane]:\n    print('{} is a {} year old {}'.format(p[0], p[1], p[2]))\n    \n>>> Bob is a 30 year old male\n>>> Jane is a 29 year old female\n"}),a.createElement("h3",null,"namedtuple definition:"),a.createElement("p",null,"namedtuple instances are just as memory efficient as regular tuples because they do not have per-instance dictionaries. Each kind of namedtuple is represented by its own class, created by using the namedtuple() factory function. The arguments are the name of the new class and a string containing the names of the elements. signature: collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)"),a.createElement(C,{language:"python",code:"# named tuples\nfrom collections import namedtuple\n \nPerson = namedtuple('Person', ['name', 'age', 'gender'])\n \nbob = Person(name='Bob', age=30, gender='male')\njane = Person(name='Jane', age=29, gender='female')\n \nfor p in [bob, jane]:\n    print('{} is a {} year old {}'.format(p.name, p.age, p.gender))\n    \n>>> Bob is a 30 year old male\n>>> Jane is a 29 year old female\n"}),a.createElement("p",null,a.createElement("strong",null,a.createElement("i",null,"rename"))," handles cases where the field names of the tuple are invalid - duplicated or using keywords as 'def'. if 'rename' is defined to True, it will handle those invalid field names and will not raise an exception. For example, ['abc', 'def', 'ghi', 'abc'] is converted to ['abc', '_1', 'ghi', '_3'], eliminating the keyword def and the duplicate fieldname abc."),a.createElement("p",null,a.createElement("strong",null,a.createElement("i",null,"defaults"))," can be None or an iterable of default values. Since fields with a default value must come after any fields without a default, the defaults are applied to the rightmost parameters. For example, if the fieldnames are ['x', 'y', 'z'] and the defaults are (1, 2), then x will be a required argument, y will default to 1, and z will default to 2."),a.createElement("p",null,"If ",a.createElement("strong",null,a.createElement("i",null,"module"))," is defined, the __module__ attribute of the named tuple is set to that value."),a.createElement("p",null),a.createElement("p",null,"since a namedtuple is a class, we can modify it for different purposes. for example - printing. Note - defining __slots__ as an empty tuple is a technique to avoid creation of instance dictionaries, and by this keeping low memory requirements."),a.createElement(C,{language:"python",code:"# named tuples with modifications\nfrom collections import namedtuple\n \n \nclass Person(namedtuple('Person', ['name', 'age', 'gender'])):\n    __slots__ = ()\n \n    def __str__(self):\n        return '{} is a {} year old {}'.format(self.name, self.age, self.gender)\n \n \nbob = Person(name='Bob', age=30, gender='male')\njane = Person(name='Jane', age=29, gender='female')\n \nfor p in [bob, jane]:\n    print('{} is a {} year old {}'.format(p.name, p.age, p.gender))\n    \n>>> Bob is a 30 year old male\n>>> Jane is a 29 year old female\n"}),a.createElement("p",null,"_make method makes a new instance from an existing sequence or iterable:"),a.createElement(C,{language:"python",code:"# using _make\nfrom collections import namedtuple\n \nAccount = namedtuple('Account', ['owner', 'balance', 'transaction_count'])\nJohn = ['John Doe', 1000, 1]\njohns_account = Account._make(John)\n \nprint(johns_account)\n\n>>> Account(owner='John Doe', balance=1000, transaction_count=1)"}),a.createElement("p",null,"it is also easy to add fields to namedtuples by using the _fields attribute:"),a.createElement(C,{language:"python",code:"# adding fields\nfrom collections import namedtuple\n \nPoint = namedtuple('Point', ['x', 'y'])\n \nPoint3D = namedtuple('Point3D', Point._fields + ('z',))\n \nfor p in Point(3,4), Point3D(10, 0, 3):\n    print(p)\n    \n>>> Point(x=3, y=4)\n>>> Point3D(x=10, y=0, z=3)\n"}),a.createElement("p",null,"lastly, for creating defaults or templates namedtuples, that will later be modified, we should use the _replace attribute."),a.createElement("p",null,"trying to replace the fields directly, will result in AttributeError:"),a.createElement(C,{language:"python",code:"from collections import namedtuple\n \nAccount = namedtuple('Account', ['owner', 'balance', 'transaction_count'])\ndefault_account = Account('<owner name>', 0.0, 0)\njohns_account = default_account\njohns_account.owner = 'John'\n \n \n>>>\nTraceback (most recent call last):\n  File \"<input>\", line 6, in <module>\nAttributeError: can't set attribute"}),a.createElement("p",null,"the right way to do that is:"),a.createElement(C,{language:"python",code:"from collections import namedtuple\n \nAccount = namedtuple('Account', ['owner', 'balance', 'transaction_count'])\ndefault_account = Account('<owner name>', 0.0, 0)\n \njohns_account = default_account._replace(owner='John')\nprint(johns_account)\n \n \n>>>\nAccount(owner='John', balance=0.0, transaction_count=0)"}),a.createElement("p",null,"Named tuples can be extremely useful when working with csv files. Say we have this csv file:"),a.createElement(C,{language:"csv",code:"empl.csv\n\nJohn Smith, 35, Accounting\nErica Meyers, 29, IT"}),a.createElement("p",null,"We could use namedtuple() to parse it"),a.createElement(C,{language:"python",code:"# csv reader\n \nimport csv\nfrom collections import namedtuple\n\nEmployeeRecord = namedtuple('EmployeeRecord', ['name', 'age', 'title'])\n \na = csv.reader(open(\"empl.csv\", \"rt\"))\nfor emp in map(EmployeeRecord._make, a):\n    print(emp.name, emp.title)\n    \n>>> John Smith  Accounting\n>>> Erica Meyers  IT\n"}),a.createElement("hr",null),a.createElement("p",null,"find more information about namedtuples and the collections module in the official python documentation:",a.createElement("a",{href:"https://docs.python.org/3/library/collections.html",target:"_blank",rel:"noopener noreferrer"},"https://docs.python.org/3/library/collections.html")))},J=function(e){var t=e.match.params.name,n=_.find(function(e){return e.name===t}),o=function(e){var t;switch(e){case"full-stack-development":t=I;break;case"python-classes":t=F;break;case"python-decorators":t=L;break;case"python-dependencies-management":t=O;break;case"python-dunders":t=W;break;case"python-first-order-functions":t=q;break;case"python-functions":t=z;break;case"python-generators":t=D;break;case"python-named-tuple":t=H;break;default:t=""}return t}(t),l=Object(a.useState)({upvotes:0,comments:[]}),i=Object(v.a)(l,2),s=i[0],c=i[1];if(Object(a.useEffect)(function(){!function(){var e=Object(E.a)(y.a.mark(function e(){var n,a;return y.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:return e.next=2,fetch("/api/articles/".concat(t));case 2:return n=e.sent,e.next=5,n.json();case 5:a=e.sent,c(a);case 7:case"end":return e.stop()}},e)}));return function(){return e.apply(this,arguments)}}()()},[t]),!n)return r.a.createElement(k,null);var u=_.filter(function(e){return e.name!==t});return r.a.createElement(r.a.Fragment,null,r.a.createElement("h1",null,n.title),r.a.createElement(T,{articleName:t,upvotes:s.upvotes,setArticleInfo:c}),r.a.createElement(o,null),r.a.createElement(x,{comments:s.comments}),r.a.createElement(A,{articleName:t,setArticleInfo:c}),r.a.createElement("h3",null,"Other Articles:"),r.a.createElement(g,{articles:u}))},B=function(){return r.a.createElement("nav",null,r.a.createElement("ul",null,r.a.createElement("li",null,r.a.createElement(m.b,{to:"/"},"Home")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/about"},"About")),r.a.createElement("li",null,r.a.createElement(m.b,{to:"/articles-list"},"Articles"))))},M=(n(245),function(e){function t(){return Object(i.a)(this,t),Object(c.a)(this,Object(u.a)(t).apply(this,arguments))}return Object(d.a)(t,e),Object(s.a)(t,[{key:"render",value:function(){return r.a.createElement(m.a,null,r.a.createElement("div",{className:"App"},r.a.createElement(B,null),r.a.createElement("div",{id:"page-body"},r.a.createElement(h.c,null,r.a.createElement(h.a,{path:"/",component:p,exact:!0}),r.a.createElement(h.a,{path:"/about",component:f}),r.a.createElement(h.a,{path:"/articles-list",component:w}),r.a.createElement(h.a,{path:"/article/:name",component:J}),r.a.createElement(h.a,{component:k})))))}}]),t}(a.Component));Boolean("localhost"===window.location.hostname||"[::1]"===window.location.hostname||window.location.hostname.match(/^127(?:\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/));l.a.render(r.a.createElement(M,null),document.getElementById("root")),"serviceWorker"in navigator&&navigator.serviceWorker.ready.then(function(e){e.unregister()})},36:function(e,t,n){e.exports=n(246)},41:function(e,t,n){}},[[36,1,2]]]);
//# sourceMappingURL=main.cbb75d7b.chunk.js.map